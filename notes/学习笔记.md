<<<<<<< HEAD
# **模块二**
## 函数式编程范式
### 函数复习
#### 一等公民
函数也是对象，可以把函数像值一样处理
作为参数或者返回值，即高阶函数

#### 高阶函数意义
使函数更加灵活，屏蔽实现的细节，只需关注目标
可以抽象通用的问题

#### 闭包的本质
函数在执行的时候会放到一个执行栈，执行完毕后其作用域下的变量和函数会被释放。若被外部引用，则暂时不会被释放。

### 函数式编程基础
#### 纯函数
同输入同输出，不保留中间的计算结果

- 可缓存
- 可测试
- 并行处理

#### 不纯函数
同输入不同输出

#### 副作用
- 副作用让一个函数变得不纯，如果函数依赖外部的状态就无法保证同输入同输出，则会带来副作用。
- 副作用来源：配置文件，数据库，用户的输入
- 副作用使得方法复用性下降，给程序带来安全隐患和不确定性，但是副作用不可能完全禁止，需要尽让其在可控范围内发生。

### 柯里化
1. 当一个函数有多个参数的时候先传递一部分参数调用它。
2. 返回一个新的函数接受剩余的参数，并返回结果。

- 柯里化可以让我们给一个函数传递较少的参数得到一个已经记住某些固定参数的新函数
- 这是一种对函数参数的缓存
- 让函数变得更灵活，让函数的粒度更小
- 可以把多元函数转换成一元函数，可以组合使用产生强大的功能

#### 组合函数

#### Lodash
数据优先，函数置后

#### Lodash-fp
函数优先，数据置后

#### Point Free
把数据处理的过程定义成与数据无关的合成运算，不需要用到代表数据的那个参数，只要把简单的运算步骤合成到一起。

- 不需要指明处理的数据
- 只需要合成运算的过程
- 需要定义一些辅助的基本运算函数

### 函子 Functor
- 函子就是一个是实现了map契约的对象
- 把函子看作一个盒子，盒子里面封装了一个值
- 处理函子中的值，给map方法传入一个处理值的函数，又该函数进行处理。
- map方法返回一个包含新值的函子

#### Maybe
内部value保存值，对异常进行处理
#### Either
内部value保存值，对异常进行处理
#### IO
内部value存储一个函数，延迟执行函数，控制副作用
#### Task
进行异步处理
#### Monad
解决函子嵌套问题，内部有静态`of`和`join`方法

## JavaScript性能优化
1. 内存管理
2. 垃圾回收和常见的GC算法
3. V8 引擎的垃圾回收
4. Performance 工具
5. 代码优化实例

### 内存管理
- 内存：
由可读写单元组成，可操作的空间
- 管理：人为操作空间的申请，使用和释放
- 流程：
1. 申请：声明
2. 使用：读写
3. 释放：空值`null`

#### JavaScript 中的垃圾
- 对象不再被引用时
- 对象不能从根上访问时

### GC算法
一个机制

#### 引用计数
优点：
- 即时回收垃圾对象
- 最大限度减少程序暂停
缺点：
- 无法回收循环引用的对象
- 时间，资源开销大

#### 标记清除
优点：
- 解决循环引用无法回收的问题
缺点：
- 空间碎片化，地址不连续
- 不会立即回收垃圾

#### 标记整理
优点：
- 减少空间碎片化
缺点：
- 不会立即回收垃圾


### V8引擎
1. 主流的JavaScript执行引擎
2. V8 采用即时编译，速度很快
3. V8 内存设限，64位系统下不超过1.5G，32位系统下不超过800M

#### V8常用GC算法
1. 分代回收
2. 空间复制
3. 标记清除
4. 标记整理
5. 标记增量

#### 新生代对象
- 存活时间较短的对象
- 32M / 16M
- 复制算法 + 标记整理

#### 老生代对象
1. 标记清除
2. 标记整理（当新生代对象移动到老生代对象移动的时候并且空间不足）
3. 增量标记（分段完成）

### Performance 工具
谷歌浏览器提供的性能工具
#### 内存问题的表现
页面出现延迟家在或者经常性暂停
页面持续性出现糟糕的性能
页面性能随着时间越来越差

内存泄漏：内存使用持续升高
内存膨胀：在多数设备上存在性能问题
频繁的垃圾回收：通过内存变化图进行分析

#### 监控内存的方式
浏览器任务管理器
Timeline 时序图记录
堆快照查找分离DOM
判断是否存在频繁的垃圾回收

#### 为什么要确定频繁的垃圾回收
- GC工作时应用程序是停止的
- 频繁过长的GC会导致应用假死
- 用户使用中感知应用卡顿

#### 频繁垃圾回收的表现
- Timeline中频繁的上升和下降
- 任务管理器中数据频繁的增加减少

#### 优化
- 慎用全局变量
- 缓存全局变量
- 通过原型新增方法
- 避开闭包陷阱
- 避免属性方法的使用
- for循环优化
缓存遍历的长度
- 选择最优的循环方法 
`forEach`>`for`>`for...in`
- 节点添加的优化
采用文档碎片方法`document.createDocumentFragment()`
- 克隆优化节点操作`node.cloneNode()`
- 用字面量替换实例化
=======
# **开发脚手架及封装自动化构建工作流**
## 工程化
1. 解决问题
- 传统语言或者语法的弊端
- 无法使用模块化 / 组建化
- 重复的机械式工作
2. 价值
- 代码风格统一，质量保证
- 依赖后端服务借口的支持
- 整体依赖后端项目


## 脚手架工具
本质作用：创建项目基础结构，提供项目规范和约定（组织结构，开发范式，模块依赖，工具配置，基础代码）
工作原理：实际上是cli应用
1. yarn / npm init 初始化一个 package.json 文件
2. 在 package.json 里bin字段定义入口文件
3. npx / yarn link 命令可以连接到全局
4. 创建模版目录和模版文件，在模版文件里使用`<%= 输入内容 %>`可以接收inquirer 交互回来的数据
5. 通过命令行交互询问用户问题
- 安装 inquirer 模块
- 使用`inquirer.prompt()`方法提出问题，参数为对象数组，对象属性有type，name，message
- 可链式调用`then()`对答案进行处理
6. 根据用户回答的结果生成文件
- 倒入 path 和 fs 模块
- 安装模版引擎`yarn add ejs`
- 使用`path.join()`生成模版目录，`__dirname`可获取当前文件路径
- 使用`process.cwd()`获取命令行目录作为目标目录
- 使用`fs.readdir()`读取文件目录，第一个参数为模版文件路径，第二参数为回调函数，回调函数的第一个参数为错误对象，第二个参数为文件的相对路径
- 使用模版引擎方法`ejs.renderFile()`渲染文件，第一个参数为文件的绝对路径，第二个参数为需要填入的数据，第三个参数为回调函数，回调函数的第一个参数为错误对象，第二个参数为渲染结果
- 使用`fs.writeFileSync()`写入到目标文件，第一个参数为目标路径，第二个参数为写入内容


## 自动化构建

### Grunt
1. yarn / npm init 初始化一个 package.json 文件
2. 入口文件为 gruntfile.js
3. 导出参数为 grunt 的函数，函数内部使用相应的API创建任务
4. 使用`grunt.registerTask()`方法注册任务，第一个参数指定任务名字，第二个参数指定回调函数
5. 如果给`grunt.registerTask()`的第一个参数传入 default，那么后面传入的任务为启动grunt时执行的默认任务。第二个参数可传入任务数组，数组每个元素为已注册的任务，那么默认会一次执行数组里的任务
6. 对于执行异步任务，结束后需要执行内部的`this.async()`以指明异步任务的结束
7. 在注册任务里`return false`可以标记任务失败，在默认任务数组里，失败的任务后续的任务不会被执行，除非使用 --force 命令
8. 使用`grunt.initConfig()`进行目标配置
9. `grunt.loadNpmTasks()`加载插件
10. 使用 load-grunt-tasks 可以自动加载所有 grunt 的插件
11. 使用 yarn / npx grunt 运行注册的任务


### Gulp
#### 工作原理：读取流=>转换流=>写入流
1. yarn / npm init 初始化一个 package.json 文件
2. 入口文件为 gulpfile.js
3. 任务中使用`src()`和链式调用`pipe()`进行流的处理
4. 使用`dest()`写入目标目录
5. 组合任务
- 串行任务`series()`，依次执行多个任务
- 并行任务`parallel()`，同时执行多个任务
6. 使用 yarn / npx gulp 执行相应的任务
>>>>>>> fed-e-task-02-01
