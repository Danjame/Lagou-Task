# **模块二**
## 函数式编程范式
### 函数复习
#### 一等公民
函数也是对象，可以把函数像值一样处理
作为参数或者返回值，即高阶函数

#### 高阶函数意义
使函数更加灵活，屏蔽实现的细节，只需关注目标
可以抽象通用的问题

#### 闭包的本质
函数在执行的时候会放到一个执行栈，执行完毕后其作用域下的变量和函数会被释放。若被外部引用，则暂时不会被释放。

### 函数式编程基础
#### 纯函数
同输入同输出，不保留中间的计算结果

- 可缓存
- 可测试
- 并行处理

#### 不纯函数
同输入不同输出

#### 副作用
- 副作用让一个函数变得不纯，如果函数依赖外部的状态就无法保证同输入同输出，则会带来副作用。
- 副作用来源：配置文件，数据库，用户的输入
- 副作用使得方法复用性下降，给程序带来安全隐患和不确定性，但是副作用不可能完全禁止，需要尽让其在可控范围内发生。

### 柯里化
1. 当一个函数有多个参数的时候先传递一部分参数调用它。
2. 返回一个新的函数接受剩余的参数，并返回结果。

- 柯里化可以让我们给一个函数传递较少的参数得到一个已经记住某些固定参数的新函数
- 这是一种对函数参数的缓存
- 让函数变得更灵活，让函数的粒度更小
- 可以把多元函数转换成一元函数，可以组合使用产生强大的功能

#### 组合函数

#### Lodash
数据优先，函数置后

#### Lodash-fp
函数优先，数据置后

#### Point Free
把数据处理的过程定义成与数据无关的合成运算，不需要用到代表数据的那个参数，只要把简单的运算步骤合成到一起。

- 不需要指明处理的数据
- 只需要合成运算的过程
- 需要定义一些辅助的基本运算函数

### 函子 Functor
- 函子就是一个是实现了map契约的对象
- 把函子看作一个盒子，盒子里面封装了一个值
- 处理函子中的值，给map方法传入一个处理值的函数，又该函数进行处理。
- map方法返回一个包含新值的函子

#### Maybe
内部value保存值，对异常进行处理
#### Either
内部value保存值，对异常进行处理
#### IO
内部value存储一个函数，延迟执行函数，控制副作用
#### Task
进行异步处理
#### Monad
解决函子嵌套问题，内部有静态`of`和`join`方法

## JavaScript性能优化
- 内存管理
- 垃圾回收和常见的GC算法
- V8 引擎的垃圾回收
- Performance 工具
- 代码优化实例

### 
- 内存：
由可读写单元组成，可操作的空间
- 管理：人为操作空间的申请，使用和释放

1. 申请：声明
2. 使用：读写
3. 释放：空值`null`

#### JavaScript 中的垃圾
- 对象不再被引用时
- 对象不能从根上访问时

### GC算法
一个机制

#### 引用计数
优点：
- 即时回收垃圾对象
- 最大限度减少程序暂停
缺点：
- 无法回收循环引用的对象
- 时间，资源开销大

#### 标记清楚
优点：
- 解决循环引用无法回收的问题
缺点：
- 空间碎片化，地址不连续
- 不会立即回收垃圾

#### 标记整理
优点：
- 减少空间碎片化
缺点：
- 不会立即回收垃圾


### V8引擎
1. 主流的JavaScript执行引擎
2. V8 采用即时编译，速度很快
3. V8 内存设限，64位系统下不超过1.5G，32位系统下不超过800M

#### V8常用GC算法
1. 分代回收
2. 空间复制
3. 标记清楚
4. 标记整理
5. 标记增量

#### 新生代对象
- 存活时间较短的对象
- 32M / 16M
- 复制算法 + 标记整理

#### 老生代对象
1. 标记清除
2. 标记整理（当新生代对象移动到老生代对象移动的时候并且空间不足）
3. 增量标记（分段完成）

### Performance 工具
谷歌浏览器提供的性能工具
#### 内存问题的表现
页面出现延迟家在或者经常性暂停
页面持续性出现糟糕的性能
页面性能随着时间越来越差

内存泄漏：内存使用持续升高
内存膨胀：在多数设备上存在性能问题
频繁的垃圾回收：通过内存变化图进行分析

#### 监控内存的方式
浏览器任务管理器
Timeline 时序图记录
堆快照查找分离DOM
判断是否存在频繁的垃圾回收

#### 为什么要确定频繁的垃圾回收
- GC工作时应用程序是停止的
- 频繁过长的GC会导致应用假死
- 用户使用中感知应用卡顿

#### 频繁垃圾回收的表现
- Timeline中频繁的上升和下降
- 任务管理器中数据频繁的增加减少

#### 优化
- 慎用全局变量
- 缓存全局变量
- 通过原型新增方法
- 避开闭包陷阱
- 避免属性方法的使用
- for循环优化
缓存遍历的长度
- 选择最优的循环方法 
`forEach`>`for`>`for...in`
- 节点添加的优化
采用文档碎片方法`document.createDocumentFragment()`
- 克隆优化节点操作`node.cloneNode()`
- 用字面量替换实例化