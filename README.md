# fed-e-task-01-01
lagou task

### 题一
```
var a = [];
for (var i = 0; i < 10; i++) {
    a[i] = function () {
        console.log(i);
    }
}

a[6](); // 10
```

对var变量只有全局作用域和函数作用域，这里的var变量i由于是在全局上声明的所以是全局变量， 所以每一个a[i]函数里面打印出来的都是i的最终的赋值，即为i=10。

### 题二

报错，提示变量无法访问未初始化的变量tmp

虽然一开始初始化了全局变量var tmp，但是在花括号里有同名的let变量，并且形成了块级作用域，而在这个块级作用域里let tmp在初始化之前就被打印出来，所以报错。

### 题三
```
 var arr = [12, 34, 32, 89 ,4]

 console.log(Math.min(...arr)); // 4
 ```

 ### 题四
 - 作用域：对于var只有全局作用域和函数作用域，而对于let和const来说花括号就形成了块级作用域
 - 变量提升：var 会在其作用域下发生变量提升，而let和const则不会
 - 声明和赋值：var 和 let都可以先声明，在赋值，但是const必须同时声明和赋值
 - 变量和常量：var 和 let是变量，也就是可以重新赋值，而const是常量，一旦赋值无法改变，如果是引用类型的值，则引用的数据可变的，但是指针不变。

 ### 题五
// 10

setTimeout 的回调函数是一个匿名函数，所有的匿名函数的this都会指向window对象，所以这里打印了全局变量a，而不是对象的属性a

### 题六
由于Symbol的值总是独一无二，因为可以防止由于变量或者对象属性重名造成的冲突。

### 题七
对于基本数据类型：
由于值数据类型直接存放在栈内存当中，复制基本数据类型的数据会在栈内存中开辟新空间存放副本，因此复制基本数据类型即为深拷贝

对于引用数据类型：
浅拷贝就是复制引用数据类型的指针，而不复制数据本身。
深拷贝就是复制引用数据类型本身，在堆内存里开辟新的空间存放复制的数据

### 题八
